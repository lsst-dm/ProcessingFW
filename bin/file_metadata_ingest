#!/usr/bin/env python
# $Id$
# $Rev::                                  $:  # Revision of last commit.
# $LastChangedBy::                        $:  # Author of last commit. 
# $LastChangedDate::                      $:  # Date of last commit.

""" Program to ingest data files that were created external to framework """

import tempfile
import argparse
import subprocess
import os
import re
import sys
import processingfw.pfwdb as pfwdb
from processingfw.pfwdefs import *
from processingfw.fwutils import *
import processingfw.pfwutils as pfwutils
import intgutils.wclutils as wclutils

VERSION = '$Rev$'

def parse_provided_list(listname):
    """ create dictionary of files from list in file """

    filelist = {}
    try:
        with open(listname, "r") as fh:
            for line in fh:
                (fullname, filetype) = fwsplit(line, ',')
                (path, fname) = os.path.split(fullname)
                filelist[fname] = {'path': path, 'filetype': filetype}
    except Exception as err:
        fwdie("Problems reading file '%s': %s" % (filename, err), 1)
        
    return filelist

def get_list_filenames(ingestpath, filetype):
    """ create a dictionary of files in given path """

    filelist = {}
    for f in os.listdir(ingestpath):
        if os.path.isfile(ingestpath+'/'+f):
            filelist[f]  = {'path': ingestpath, 'filetype': filetype}
    return filelist


def list_not_in_db(filenames):
    """ Return list of files from given set which are not in database """

    dbh = pfwdb.PFWDB()

    dbq = "select filename from genfile where filename in ('%s')" % "','".join(filenames)
    curs = dbh.cursor()
    curs.execute(dbq)
    dblist = []
    for row in curs:
        dblist.append(row[0])

    filenames = set(filenames) - set(dblist)
    return filenames


def create_input_wcl(filelist, dbwcl):
    """ Returns input wcl for call to generic.py to get metadata collection """ 


    # group by filetype
    byfiletype = {}
    for f in filelist:
        if filelist[f]['filetype'] not in byfiletype:
            byfiletype[filelist[f]['filetype']] = []
        byfiletype[filelist[f]['filetype']].append(filelist[f]['path'] + '/' + f)

    wcl = {}
    wcl['%s1' % (IW_EXECPREFIX)] = {}
    wcl['%s1' % (IW_EXECPREFIX)]['execname'] = '/usr/bin/uptime'
    wcl['%s1' % (IW_EXECPREFIX)][IW_OUTPUTS] = []
    wcl[IW_FILESECT] = {}
    for ftype in byfiletype:
        wcl[IW_FILESECT][ftype] = pfwutils.get_metadata_wcl(ftype, ftype, dbwcl)
        wcl[IW_FILESECT][ftype]['filetype'] = ftype
        wcl[IW_FILESECT][ftype]['fullname'] = ','.join(byfiletype[ftype])
        wcl['%s1' % (IW_EXECPREFIX)][IW_OUTPUTS].append(IW_FILESECT +'.' + ftype)
     
    wcl['%s1' % (IW_EXECPREFIX)][IW_OUTPUTS] = ','.join(wcl['%s1' % (IW_EXECPREFIX)][IW_OUTPUTS])
    wcl[IW_WRAPSECT]  = {}
    wcl[IW_WRAPSECT]['pipeline'] = 'file_metadata_ingest'
    m = re.match('\$Rev: (\d+) \$', VERSION)
    wcl[IW_WRAPSECT]['pipever'] = m.group(1)
    return wcl


def write_input_wcl(inwclfile, wcl):
    """ Writes input wcl to file """
    with open(inwclfile, 'w') as fh:
        wclutils.write_wcl(wcl, fh)


def ingest_metadata(outwclfile, dbwcl, dbh):
    """ Ingests metadata from output wcl into database """

    if os.path.isfile(outwclfile):
        outwclfh = open(outwclfile, 'r')
        outputwcl = wclutils.read_wcl(outwclfh)

        if 'file_metadata' in outputwcl:
            print "Calling ingest_file_metadata on %s files" % len(outputwcl['file_metadata'])
            dbh.ingest_file_metadata(outputwcl['file_metadata'], dbwcl)
    else:
        print "Error: missing outputwcl file (%s)" % (outwclfile)


def run_generic_wrapper(inwclfile):
    """ Runs the generic wrapper using given input wcl file """

    cmd = "generic.py --input %s" % (inwclfile)
    print "Running cmd>", cmd
    process = subprocess.Popen(cmd.split(), shell=False,
                               stderr=subprocess.STDOUT)
    process.wait()
    return process.returncode


def main(args):
    parser = argparse.ArgumentParser(description='Ingest metadata for files generated outside DESDM framework')
    parser.add_argument('--operator', action='store')
    parser.add_argument('--dbwcl', action='store')
    parser.add_argument('--inputwcl', action='store')
    parser.add_argument('--outputwcl', action='store')
    parser.add_argument('--noingest', action='store_true', default=False)
    parser.add_argument('--version', action='store_true', default=False)
    parser.add_argument('--list', action='store', help='format:  fullname, filetype')
    parser.add_argument('--filetype', action='store')
    parser.add_argument('--path', action='store')

    args = vars(parser.parse_args())

    print 'Using version %s of file_metadata_ingest\n' % VERSION

    if args['version']:
        return 0

    if args['filetype'] and ',' in args['filetype']: 
        print "Error: filetype must be single value"
        parser.print_help()
        return 1

    if args['path'] and ',' in args['path']:
        print "Error: path must be single value"
        parser.print_help()
        return 1

    if args['filetype'] and args['path'] is None:
        print "Error: must specify path if using filetype" 
        parser.print_help()
        return 1

    if args['filetype'] is None and args['path']:
        print "Error: must specify filetype if using path" 
        parser.print_help()
        return 1

    dbh = pfwdb.PFWDB()
    dbwcl = dbh.get_all_filetype_metadata()

    if args['dbwcl'] is not None:
        with open(args['dbwcl'], 'w') as fh:
            wclutils.write_wcl(dbwcl, fh, True, 4)

    if args['path'] is not None:
        filelist = get_list_filenames(args['path'], args['filetype'])
    elif args['list'] is not None:
        filelist = parse_provided_list(args['list'])

    filenames = list_not_in_db(filelist.keys())

    if len(filenames) == 0:
        print "All files already in database"
        return(0)

    insfilelist = {}
    for f in filenames:
        insfilelist[f] = filelist[f]
 
    inputwcl = create_input_wcl(insfilelist, dbwcl)
   
    if args['inputwcl'] is not None:
        inwclfile = args['inputwcl']
    else:
        temp = tempfile.NamedTemporaryFile(prefix='ingest_metadata_', suffix='_input.wcl', dir='/tmp', delete=False)
        inwclfile = temp.name 

    if args['outputwcl'] is not None:
        outwclfile = args['outputwcl']
    else:
        temp = tempfile.NamedTemporaryFile(prefix='ingest_metadata_', suffix='_output.wcl', dir='/tmp', delete=False)
        outwclfile = temp.name 

    inputwcl[IW_WRAPSECT]['outputwcl'] = outwclfile
    write_input_wcl(inwclfile, inputwcl)

    if run_generic_wrapper(inwclfile):
        print "Skipping ingestion because wrapper exited with error"
        return(1)
    
    inputwcl[IW_WRAPSECT]['outputwcl'] = outwclfile

    if not args['noingest']:
        ingest_metadata(outwclfile, dbwcl, dbh)
        dbh.commit()
    

if __name__ == '__main__':
    sys.exit(main(sys.argv))

